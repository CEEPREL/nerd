"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sugar-high";
exports.ids = ["vendor-chunks/sugar-high"];
exports.modules = {

/***/ "(rsc)/./node_modules/sugar-high/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/sugar-high/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SugarHigh: () => (/* binding */ SugarHigh),\n/* harmony export */   generate: () => (/* binding */ generate),\n/* harmony export */   highlight: () => (/* binding */ highlight),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// @ts-check\n\nconst jsxBrackets = new Set(['<', '>', '{', '}', '[', ']'])\nconst keywords = new Set([\n  'for',\n  'do',\n  'while',\n  'if',\n  'else',\n  'return',\n  'function',\n  'var',\n  'let',\n  'const',\n  'true',\n  'false',\n  'undefined',\n  'this',\n  'new',\n  'delete',\n  'typeof',\n  'in',\n  'instanceof',\n  'void',\n  'break',\n  'continue',\n  'switch',\n  'case',\n  'default',\n  'throw',\n  'try',\n  'catch',\n  'finally',\n  'debugger',\n  'with',\n  'yield',\n  'async',\n  'await',\n  'class',\n  'extends',\n  'super',\n  'import',\n  'export',\n  'from',\n  'static',\n])\n\nconst signs = new Set([\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '=',\n  '!',\n  '&',\n  '|',\n  '^',\n  '~',\n  '!',\n  '?',\n  ':',\n  '.',\n  ',',\n  ';',\n  `'`,\n  '\"',\n  '.',\n  '(',\n  ')',\n  '[',\n  ']',\n  '#',\n  '@',\n  '\\\\',\n  ...jsxBrackets,\n])\n\n\n/**\n *\n * 0  - identifier\n * 1  - keyword\n * 2  - string\n * 3  - Class, number and null\n * 4  - property\n * 5  - entity\n * 6  - jsx literals\n * 7  - sign\n * 8  - comment\n * 9  - break\n * 10 - space\n *\n */\nconst types = /** @type {const} */ ([\n  'identifier',\n  'keyword',\n  'string',\n  'class',\n  'property',\n  'entity',\n  'jsxliterals',\n  'sign',\n  'comment',\n  'break',\n  'space',\n])\nconst [\n  T_IDENTIFIER,\n  T_KEYWORD,\n  T_STRING,\n  T_CLS_NUMBER,\n  T_PROPERTY,\n  T_ENTITY,\n  T_JSX_LITERALS,\n  T_SIGN,\n  T_COMMENT,\n  T_BREAK,\n  T_SPACE,\n] = /** @types {const} */ types.map((_, i) => i)\n\nfunction isSpaces(str) {\n  return /^[^\\S\\r\\n]+$/g.test(str)\n}\n\nfunction isSign(ch) {\n  return signs.has(ch)\n}\n\nfunction encode(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;')\n}\n\nfunction isWord(chr) {\n  return /^[\\w_]+$/.test(chr) || hasUnicode(chr)\n}\n\nfunction isCls(str) {\n  const chr0 = str[0]\n  return isWord(chr0) &&\n    chr0 === chr0.toUpperCase() ||\n    str === 'null'\n}\n\nfunction hasUnicode(s) {\n  return /[^\\u0000-\\u007f]/.test(s);\n}\n\nfunction isAlpha(chr) {\n  return /^[a-zA-Z]$/.test(chr)\n}\n\nfunction isIdentifierChar(chr) {\n  return isAlpha(chr) || hasUnicode(chr)\n}\n\nfunction isIdentifier(str) {\n  return isIdentifierChar(str[0]) && (str.length === 1 || isWord(str.slice(1)))\n}\n\nfunction isStrTemplateChr(chr) {\n  return chr === '`'\n}\n\nfunction isSingleQuotes(chr) {\n  return chr === '\"' || chr === \"'\"\n}\n\nfunction isStringQuotation(chr) {\n  return isSingleQuotes(chr) || isStrTemplateChr(chr)\n}\n\nfunction isCommentStart(str) {\n  str = str.slice(0, 2)\n  return str === '//' || str === '/*'\n}\n\nfunction isRegexStart(str) {\n  return str[0] === '/' && !isCommentStart(str[0] + str[1])\n}\n\n/**\n * @param {string} code\n * @return {Array<[number, string]>}\n */\nfunction tokenize(code) {\n  let current = ''\n  let type = -1\n  /** @type {[number, string]} */\n  let last = [-1, '']\n  /** @type {[number, string]} */\n  let beforeLast = [-2, '']\n  /** @type {Array<[number, string]>} */\n  const tokens = []\n\n  /** @type boolean if entered jsx tag, inside <open tag> or </close tag> */\n  let __jsxEnter = false\n  /**\n   * @type {0 | 1 | 2}\n   * @example\n   * 0 for not in jsx;\n   * 1 for open jsx tag;\n   * 2 for closing jsx tag;\n   **/\n  let __jsxTag = 0\n  let __jsxExpr = false\n\n  // only match paired (open + close) tags, not self-closing tags\n  let __jsxStack = 0\n  const __jsxChild = () => __jsxEnter && !__jsxExpr && !__jsxTag\n  // < __content__ >\n  const inJsxTag = () => __jsxTag && !__jsxChild()\n  // {'__content__'}\n  const inJsxLiterals = () => !__jsxTag && __jsxChild() && !__jsxExpr && __jsxStack > 0\n\n  /** @type {string | null} */\n  let __strQuote = null\n  let __regexQuoteStart = false\n  let __strTemplateExprStack = 0\n  let __strTemplateQuoteStack = 0\n  const inStringQuotes = () => __strQuote !== null\n  const inRegexQuotes = () => __regexQuoteStart\n  const inStrTemplateLiterals = () => (__strTemplateQuoteStack > __strTemplateExprStack)\n  const inStrTemplateExpr = () => __strTemplateQuoteStack > 0 && (__strTemplateQuoteStack === __strTemplateExprStack)\n  const inStringContent = () => inStringQuotes() || inStrTemplateLiterals()\n\n  /**\n   *\n   * @param {string} token\n   * @returns {number}\n   */\n  function classify(token) {\n    const isLineBreak = token === '\\n'\n    // First checking if they're attributes values\n    if (inJsxTag()) {\n      if (inStringQuotes()) {\n        return T_STRING\n      }\n\n      const [, lastToken] = last\n      if (isIdentifier(token)) {\n        // classify jsx open tag\n        if ((lastToken === '<' || lastToken === '</')) \n          return T_ENTITY\n      }\n    }\n    // Then determine if they're jsx literals\n    const isJsxLiterals = inJsxLiterals()\n    if (isJsxLiterals) return T_JSX_LITERALS\n\n    // Determine strings first before other types\n    if (inStringQuotes()) {\n      return T_STRING\n    } else if (keywords.has(token)) {\n      return last[1] === '.' ? T_IDENTIFIER : T_KEYWORD\n    } else if (isLineBreak) {\n      return T_BREAK\n    } else if (isSpaces(token)) {\n      return T_SPACE\n    } else if (token.split('').every(isSign)) {\n      return T_SIGN\n    } else if (isCls(token)) {\n      return inJsxTag() ? T_IDENTIFIER : T_CLS_NUMBER\n    } else {\n      if (isIdentifier(token)) {\n        const isLastPropDot = last[1] === '.' && isIdentifier(beforeLast[1])\n\n        if (!inStringContent() && !isLastPropDot) return T_IDENTIFIER\n        if (isLastPropDot) return T_PROPERTY\n      }\n      return T_STRING\n    }\n  }\n\n  /**\n   * \n   * @param {number} type_ \n   * @param {string} token_ \n   */\n  const append = (type_, token_) => {\n    if (type_ || token_) {\n      const nType = types[type_]\n    }\n    if (token_) {\n      current = token_\n    }\n    if (current) {\n      type = type_ || classify(current)\n      /** @type [number, string]  */\n      const pair = [type, current]\n      if (type !== T_SPACE && type !== T_BREAK) {\n        beforeLast = last\n        last = pair\n      }\n      tokens.push(pair)\n    }\n    current = ''\n  }\n  for (let i = 0; i < code.length; i++) {\n    const curr = code[i]\n    const prev = code[i - 1]\n    const next = code[i + 1]\n    const p_c = prev + curr // previous and current\n    const c_n = curr + next // current and next\n\n    // Determine string quotation outside of jsx literals.\n    // Inside jsx literals, string quotation is still part of it.\n    if (isSingleQuotes(curr) && !inJsxLiterals()) {\n      append()\n      if (prev !== `\\\\`) {\n        if (__strQuote && curr === __strQuote) {\n          __strQuote = null\n        } else if (!__strQuote) {\n          __strQuote = curr\n        }\n      }\n\n      append(T_STRING, curr)\n      continue\n    }\n\n    if (!inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        append()\n        append(T_STRING, curr)\n        __strTemplateQuoteStack++\n        continue\n      }\n    }\n\n    if (inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        if (__strTemplateQuoteStack > 0) {\n          append()\n          __strTemplateQuoteStack--\n          append(T_STRING, curr)\n          continue\n        }\n      }\n\n      if (c_n === '${') {\n        __strTemplateExprStack++\n        append(T_STRING)\n        append(T_SIGN, c_n)\n        i++\n        continue\n      }\n    }\n\n    if (inStrTemplateExpr() && curr === '}') {\n      append()\n      __strTemplateExprStack--\n      append(T_SIGN, curr)\n      continue\n    }\n\n    if (__jsxChild()) {\n      if (curr === '{') {\n        append()\n        append(T_SIGN, curr)\n        __jsxExpr = true\n        continue\n      }\n    }\n\n    if (__jsxEnter) {\n      // <: open tag sign\n      // new '<' not inside jsx\n      if (!__jsxTag && curr === '<') {\n        append()\n        if (next === '/') {\n          // close tag\n          __jsxTag = 2\n          current = c_n\n          i++\n        } else {\n          // open tag\n          __jsxTag = 1\n          current = curr\n        }\n        append(T_SIGN)\n        continue\n      }\n      if (__jsxTag) {\n        // >: open tag close sign or closing tag closing sign\n        // and it's not `=>` or `/>`\n        // `curr` could be `>` or `/`\n        if ((curr === '>' && !'/='.includes(prev))) {\n          append()\n          if (__jsxTag === 1) {\n            __jsxTag = 0\n            __jsxStack++\n          } else {\n            __jsxTag = 0\n            __jsxEnter = false\n          }\n          append(T_SIGN, curr)\n          continue\n        }\n\n        // >: tag self close sign or close tag sign\n        if (c_n === '/>' || c_n === '</') {\n          // if current token is not part of close tag sign, push it first\n          if (current !== '<' && current !== '/') {\n            append()\n          }\n\n          if (c_n === '/>') {\n            __jsxTag = 0\n          } else {\n            // is '</'\n            __jsxStack--\n          }\n\n          if (!__jsxStack)\n            __jsxEnter = false\n\n          current = c_n\n          i++\n          append(T_SIGN)\n          continue\n        }\n\n        // <: open tag sign\n        if (curr === '<') {\n          append()\n          current = curr\n          append(T_SIGN)\n          continue\n        }\n\n        // jsx property\n        // `-` in data-prop\n        if (next === '-'  && !inStringContent() && !inJsxLiterals()) {\n          if (current) {\n            append(T_PROPERTY, current + curr + next)\n            i += 1\n            continue\n          }\n        }\n        // `=` in property=<value>\n        if (next === '=' && !inStringContent()) {\n          // if current is not a space, ensure `prop` is a property\n          if (isSpaces(current)) {\n            append(T_SPACE, current)\n            current = ''\n          }\n          const prop = current ? (current + curr) : curr\n          if (isIdentifier(prop)) {\n            current = prop\n            append(T_PROPERTY)\n          }\n          continue\n        }\n      }\n    }\n\n    // if it's not in a jsx tag declaration or a string, close child if next is jsx close tag\n    if (!__jsxTag && (curr === '<' && isIdentifierChar(next) || c_n === '</')) {\n      __jsxTag = next === '/' ? 2 : 1\n\n      // current and next char can form a jsx open or close tag\n      if (curr === '<' && (next === '/' || isAlpha(next))) {\n        if (\n          !inStringContent() && \n          !inJsxLiterals() &&\n          !inRegexQuotes()\n        ) {\n          __jsxEnter = true\n        }\n      }\n    }\n\n    const isQuotationChar = isStringQuotation(curr)\n    const isStringTemplateLiterals = inStrTemplateLiterals()\n    const isRegexChar = !__jsxEnter && isRegexStart(c_n)\n    const isJsxLiterals = inJsxLiterals()\n\n    // string quotation\n    if (isQuotationChar || isStringTemplateLiterals || isSingleQuotes(__strQuote)) {\n      current += curr\n    } else if (isRegexChar) {\n      append()\n      const [lastType, lastToken] = last\n      // Special cases that are not considered as regex:\n      // * (expr1) / expr2: `)` before `/` operator is still in expression\n      // * <non comment start>/ expr: non comment start before `/` is not regex\n      if (\n        isRegexChar &&\n        lastType !== -1 &&\n        !(\n          (lastType === T_SIGN && ')' !== lastToken) ||\n          lastType === T_COMMENT\n        )\n      ) {\n        current = curr\n        append()\n        continue\n      }\n\n      __regexQuoteStart = true\n      const start = i++\n\n      // end of line of end of file\n      const isEof = () => i >= code.length\n      const isEol = () => isEof() || code[i] === '\\n'\n\n      let foundClose = false\n      \n      // traverse to find closing regex slash\n      for (; !isEol(); i++) {\n        if (code[i] === '/' && code[i - 1] !== '\\\\') {\n          foundClose = true\n          // end of regex, append regex flags\n          while (start !== i && /^[a-z]$/.test(code[i + 1]) && !isEol()) {\n            i++\n          }\n          break\n        }\n      }\n      __regexQuoteStart = false\n\n      if (start !== i && foundClose) {\n        // If current line is fully closed with string quotes or regex slashes,\n        // add them to tokens\n        current = code.slice(start, i + 1)\n        append(T_STRING)\n      } else {\n        // If it doesn't match any of the above, just leave it as operator and move on\n        current = curr\n        append()\n        i = start\n      }\n    } else if (isCommentStart(c_n)) {\n      append()\n      const start = i\n      if (next === '/') {\n        for (; i < code.length && code[i] !== '\\n'; i++);\n      } else {\n        for (; i < code.length && code[i - 1] + code[i] !== '*/'; i++);\n      }\n      current = code.slice(start, i + 1)\n      append(T_COMMENT)\n    } else if (curr === ' ' || curr === '\\n') {\n      if (\n        curr === ' ' &&\n        (\n          (isSpaces(current) || !current) ||\n          isJsxLiterals\n        )\n      ) {\n        current += curr\n        if (next === '<') {\n          append()\n        }\n      } else {\n        append()\n        current = curr\n        append()\n      }\n    } else {\n      if (__jsxExpr && curr === '}') {\n        append()\n        current = curr\n        append()\n        __jsxExpr = false\n      } else if (\n        // it's jsx literals and is not a jsx bracket\n        (isJsxLiterals && !jsxBrackets.has(curr)) ||\n        // same type char as previous one in current token\n        ((isWord(curr) === isWord(current[current.length - 1]) || __jsxChild()) && !signs.has(curr))\n      ) {\n        current += curr\n      } else {\n        if (p_c === '</') {\n          current = p_c\n        }\n        append()\n\n        if (p_c !== '</') {\n          current = curr\n\n        }\n        if ((c_n === '</' || c_n === '/>')) {\n          current = c_n\n          append()\n          i++\n        }\n        else if (jsxBrackets.has(curr)) append()\n      }\n    }\n  }\n\n  append()\n\n  return tokens\n}\n\n/**\n * @param {Array<[number, string]>} tokens\n * @return {Array<any>}\n */\nfunction generate(tokens) {\n  const lines = []\n  /**\n   * @param {any} children\n   * @return {{type: string, tagName: string, children: any[], properties: Record<string, string>}}\n   */\n  const createLine = (children) => \n      ({\n        type: 'element',\n        tagName: 'span',\n        children,\n        properties: {\n          className: 'sh__line',\n        },\n      })\n\n  /**\n   * @param {Array<[number, string]>} tokens\n   * @returns {void}\n   */\n  function flushLine(tokens) {\n    /** @type {Array<any>} */\n    const lineTokens = (\n      tokens\n        .map(([type, value]) => (\n          {\n            type: 'element',\n            tagName: 'span',\n            children: [{\n              type: 'text',\n              value: value, // to encode\n            }],\n            properties: {\n              className: `sh__token--${types[type]}`,\n              style: `color: var(--sh-${types[type]})`,\n            },\n          }\n        ))\n    )\n    lines.push(createLine(lineTokens))\n  }\n  /** @type {Array<[number, string]>} */\n  const lineTokens = []\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n    const [type, value] = token\n    if (type !== T_BREAK) {\n      // Divide multi-line token into multi-line code\n      if (value.includes('\\n')) {\n        const lines = value.split('\\n')\n        for (let j = 0; j < lines.length; j++) {\n          lineTokens.push([type, lines[j]])\n          if (j < lines.length - 1) {\n            flushLine(lineTokens)\n            lineTokens.length = 0\n          }\n        }\n      } else {\n        lineTokens.push(token)\n      }\n    } else {\n      lineTokens.push([type, ''])\n      flushLine(lineTokens)\n      lineTokens.length = 0\n    }\n  }\n\n  if (lineTokens.length)\n    flushLine(lineTokens)\n\n  return lines\n}\n\nfunction toHtml(lines) {\n  return lines\n    .map(line => {\n      const { tagName: lineTag } = line\n      const tokens = line.children\n        .map(child => {\n          const { tagName, children, properties } = child\n          return `<${tagName} class=\"${\n            properties.className\n          }\" style=\"${\n            properties.style\n          }\">${encode(children[0].value)}</${tagName}>`\n        })\n        .join('')\n      return `<${lineTag} class=\"${line.properties.className}\">${tokens}</${lineTag}>`\n    })\n    .join('\\n')\n}\n\n/**\n *\n * @param {string} code\n * @returns {string}\n */\nfunction highlight(code) {\n  const tokens = tokenize(code)\n  const lines = generate(tokens)\n  const output = toHtml(lines)\n  return output\n}\n\n// namespace\nconst SugarHigh = /** @type {const} */ {\n  TokenTypes: types,\n  TokenMap: new Map(types.map((type, i) => [type, i])),\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTzs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRCxRQUFRO0FBQ1IsZUFBZSxtREFBbUQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVDQUF1QyxZQUFZO0FBQ25ELHdDQUF3QyxZQUFZO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQscUJBQXFCLFNBQVM7QUFDOUI7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXLElBQUksMEJBQTBCLElBQUksUUFBUTtBQUNyRCxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUIsU0FBUyxTQUFTLDBCQUEwQixJQUFJLE9BQU8sSUFBSSxRQUFRO0FBQ3BGLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBOztBQU9DIiwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9va3Byby9Eb2N1bWVudHMvbmVyZC9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLWNoZWNrXG5cbmNvbnN0IGpzeEJyYWNrZXRzID0gbmV3IFNldChbJzwnLCAnPicsICd7JywgJ30nLCAnWycsICddJ10pXG5jb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQoW1xuICAnZm9yJyxcbiAgJ2RvJyxcbiAgJ3doaWxlJyxcbiAgJ2lmJyxcbiAgJ2Vsc2UnLFxuICAncmV0dXJuJyxcbiAgJ2Z1bmN0aW9uJyxcbiAgJ3ZhcicsXG4gICdsZXQnLFxuICAnY29uc3QnLFxuICAndHJ1ZScsXG4gICdmYWxzZScsXG4gICd1bmRlZmluZWQnLFxuICAndGhpcycsXG4gICduZXcnLFxuICAnZGVsZXRlJyxcbiAgJ3R5cGVvZicsXG4gICdpbicsXG4gICdpbnN0YW5jZW9mJyxcbiAgJ3ZvaWQnLFxuICAnYnJlYWsnLFxuICAnY29udGludWUnLFxuICAnc3dpdGNoJyxcbiAgJ2Nhc2UnLFxuICAnZGVmYXVsdCcsXG4gICd0aHJvdycsXG4gICd0cnknLFxuICAnY2F0Y2gnLFxuICAnZmluYWxseScsXG4gICdkZWJ1Z2dlcicsXG4gICd3aXRoJyxcbiAgJ3lpZWxkJyxcbiAgJ2FzeW5jJyxcbiAgJ2F3YWl0JyxcbiAgJ2NsYXNzJyxcbiAgJ2V4dGVuZHMnLFxuICAnc3VwZXInLFxuICAnaW1wb3J0JyxcbiAgJ2V4cG9ydCcsXG4gICdmcm9tJyxcbiAgJ3N0YXRpYycsXG5dKVxuXG5jb25zdCBzaWducyA9IG5ldyBTZXQoW1xuICAnKycsXG4gICctJyxcbiAgJyonLFxuICAnLycsXG4gICclJyxcbiAgJz0nLFxuICAnIScsXG4gICcmJyxcbiAgJ3wnLFxuICAnXicsXG4gICd+JyxcbiAgJyEnLFxuICAnPycsXG4gICc6JyxcbiAgJy4nLFxuICAnLCcsXG4gICc7JyxcbiAgYCdgLFxuICAnXCInLFxuICAnLicsXG4gICcoJyxcbiAgJyknLFxuICAnWycsXG4gICddJyxcbiAgJyMnLFxuICAnQCcsXG4gICdcXFxcJyxcbiAgLi4uanN4QnJhY2tldHMsXG5dKVxuXG5cbi8qKlxuICpcbiAqIDAgIC0gaWRlbnRpZmllclxuICogMSAgLSBrZXl3b3JkXG4gKiAyICAtIHN0cmluZ1xuICogMyAgLSBDbGFzcywgbnVtYmVyIGFuZCBudWxsXG4gKiA0ICAtIHByb3BlcnR5XG4gKiA1ICAtIGVudGl0eVxuICogNiAgLSBqc3ggbGl0ZXJhbHNcbiAqIDcgIC0gc2lnblxuICogOCAgLSBjb21tZW50XG4gKiA5ICAtIGJyZWFrXG4gKiAxMCAtIHNwYWNlXG4gKlxuICovXG5jb25zdCB0eXBlcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICdpZGVudGlmaWVyJyxcbiAgJ2tleXdvcmQnLFxuICAnc3RyaW5nJyxcbiAgJ2NsYXNzJyxcbiAgJ3Byb3BlcnR5JyxcbiAgJ2VudGl0eScsXG4gICdqc3hsaXRlcmFscycsXG4gICdzaWduJyxcbiAgJ2NvbW1lbnQnLFxuICAnYnJlYWsnLFxuICAnc3BhY2UnLFxuXSlcbmNvbnN0IFtcbiAgVF9JREVOVElGSUVSLFxuICBUX0tFWVdPUkQsXG4gIFRfU1RSSU5HLFxuICBUX0NMU19OVU1CRVIsXG4gIFRfUFJPUEVSVFksXG4gIFRfRU5USVRZLFxuICBUX0pTWF9MSVRFUkFMUyxcbiAgVF9TSUdOLFxuICBUX0NPTU1FTlQsXG4gIFRfQlJFQUssXG4gIFRfU1BBQ0UsXG5dID0gLyoqIEB0eXBlcyB7Y29uc3R9ICovIHR5cGVzLm1hcCgoXywgaSkgPT4gaSlcblxuZnVuY3Rpb24gaXNTcGFjZXMoc3RyKSB7XG4gIHJldHVybiAvXlteXFxTXFxyXFxuXSskL2cudGVzdChzdHIpXG59XG5cbmZ1bmN0aW9uIGlzU2lnbihjaCkge1xuICByZXR1cm4gc2lnbnMuaGFzKGNoKVxufVxuXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzAzOTsnKVxufVxuXG5mdW5jdGlvbiBpc1dvcmQoY2hyKSB7XG4gIHJldHVybiAvXltcXHdfXSskLy50ZXN0KGNocikgfHwgaGFzVW5pY29kZShjaHIpXG59XG5cbmZ1bmN0aW9uIGlzQ2xzKHN0cikge1xuICBjb25zdCBjaHIwID0gc3RyWzBdXG4gIHJldHVybiBpc1dvcmQoY2hyMCkgJiZcbiAgICBjaHIwID09PSBjaHIwLnRvVXBwZXJDYXNlKCkgfHxcbiAgICBzdHIgPT09ICdudWxsJ1xufVxuXG5mdW5jdGlvbiBoYXNVbmljb2RlKHMpIHtcbiAgcmV0dXJuIC9bXlxcdTAwMDAtXFx1MDA3Zl0vLnRlc3Qocyk7XG59XG5cbmZ1bmN0aW9uIGlzQWxwaGEoY2hyKSB7XG4gIHJldHVybiAvXlthLXpBLVpdJC8udGVzdChjaHIpXG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY2hyKSB7XG4gIHJldHVybiBpc0FscGhhKGNocikgfHwgaGFzVW5pY29kZShjaHIpXG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgcmV0dXJuIGlzSWRlbnRpZmllckNoYXIoc3RyWzBdKSAmJiAoc3RyLmxlbmd0aCA9PT0gMSB8fCBpc1dvcmQoc3RyLnNsaWNlKDEpKSlcbn1cblxuZnVuY3Rpb24gaXNTdHJUZW1wbGF0ZUNocihjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gJ2AnXG59XG5cbmZ1bmN0aW9uIGlzU2luZ2xlUXVvdGVzKGNocikge1xuICByZXR1cm4gY2hyID09PSAnXCInIHx8IGNociA9PT0gXCInXCJcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdRdW90YXRpb24oY2hyKSB7XG4gIHJldHVybiBpc1NpbmdsZVF1b3RlcyhjaHIpIHx8IGlzU3RyVGVtcGxhdGVDaHIoY2hyKVxufVxuXG5mdW5jdGlvbiBpc0NvbW1lbnRTdGFydChzdHIpIHtcbiAgc3RyID0gc3RyLnNsaWNlKDAsIDIpXG4gIHJldHVybiBzdHIgPT09ICcvLycgfHwgc3RyID09PSAnLyonXG59XG5cbmZ1bmN0aW9uIGlzUmVnZXhTdGFydChzdHIpIHtcbiAgcmV0dXJuIHN0clswXSA9PT0gJy8nICYmICFpc0NvbW1lbnRTdGFydChzdHJbMF0gKyBzdHJbMV0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEByZXR1cm4ge0FycmF5PFtudW1iZXIsIHN0cmluZ10+fVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZShjb2RlKSB7XG4gIGxldCBjdXJyZW50ID0gJydcbiAgbGV0IHR5cGUgPSAtMVxuICAvKiogQHR5cGUge1tudW1iZXIsIHN0cmluZ119ICovXG4gIGxldCBsYXN0ID0gWy0xLCAnJ11cbiAgLyoqIEB0eXBlIHtbbnVtYmVyLCBzdHJpbmddfSAqL1xuICBsZXQgYmVmb3JlTGFzdCA9IFstMiwgJyddXG4gIC8qKiBAdHlwZSB7QXJyYXk8W251bWJlciwgc3RyaW5nXT59ICovXG4gIGNvbnN0IHRva2VucyA9IFtdXG5cbiAgLyoqIEB0eXBlIGJvb2xlYW4gaWYgZW50ZXJlZCBqc3ggdGFnLCBpbnNpZGUgPG9wZW4gdGFnPiBvciA8L2Nsb3NlIHRhZz4gKi9cbiAgbGV0IF9fanN4RW50ZXIgPSBmYWxzZVxuICAvKipcbiAgICogQHR5cGUgezAgfCAxIHwgMn1cbiAgICogQGV4YW1wbGVcbiAgICogMCBmb3Igbm90IGluIGpzeDtcbiAgICogMSBmb3Igb3BlbiBqc3ggdGFnO1xuICAgKiAyIGZvciBjbG9zaW5nIGpzeCB0YWc7XG4gICAqKi9cbiAgbGV0IF9fanN4VGFnID0gMFxuICBsZXQgX19qc3hFeHByID0gZmFsc2VcblxuICAvLyBvbmx5IG1hdGNoIHBhaXJlZCAob3BlbiArIGNsb3NlKSB0YWdzLCBub3Qgc2VsZi1jbG9zaW5nIHRhZ3NcbiAgbGV0IF9fanN4U3RhY2sgPSAwXG4gIGNvbnN0IF9fanN4Q2hpbGQgPSAoKSA9PiBfX2pzeEVudGVyICYmICFfX2pzeEV4cHIgJiYgIV9fanN4VGFnXG4gIC8vIDwgX19jb250ZW50X18gPlxuICBjb25zdCBpbkpzeFRhZyA9ICgpID0+IF9fanN4VGFnICYmICFfX2pzeENoaWxkKClcbiAgLy8geydfX2NvbnRlbnRfXyd9XG4gIGNvbnN0IGluSnN4TGl0ZXJhbHMgPSAoKSA9PiAhX19qc3hUYWcgJiYgX19qc3hDaGlsZCgpICYmICFfX2pzeEV4cHIgJiYgX19qc3hTdGFjayA+IDBcblxuICAvKiogQHR5cGUge3N0cmluZyB8IG51bGx9ICovXG4gIGxldCBfX3N0clF1b3RlID0gbnVsbFxuICBsZXQgX19yZWdleFF1b3RlU3RhcnQgPSBmYWxzZVxuICBsZXQgX19zdHJUZW1wbGF0ZUV4cHJTdGFjayA9IDBcbiAgbGV0IF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID0gMFxuICBjb25zdCBpblN0cmluZ1F1b3RlcyA9ICgpID0+IF9fc3RyUXVvdGUgIT09IG51bGxcbiAgY29uc3QgaW5SZWdleFF1b3RlcyA9ICgpID0+IF9fcmVnZXhRdW90ZVN0YXJ0XG4gIGNvbnN0IGluU3RyVGVtcGxhdGVMaXRlcmFscyA9ICgpID0+IChfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA+IF9fc3RyVGVtcGxhdGVFeHByU3RhY2spXG4gIGNvbnN0IGluU3RyVGVtcGxhdGVFeHByID0gKCkgPT4gX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPiAwICYmIChfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA9PT0gX19zdHJUZW1wbGF0ZUV4cHJTdGFjaylcbiAgY29uc3QgaW5TdHJpbmdDb250ZW50ID0gKCkgPT4gaW5TdHJpbmdRdW90ZXMoKSB8fCBpblN0clRlbXBsYXRlTGl0ZXJhbHMoKVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGNsYXNzaWZ5KHRva2VuKSB7XG4gICAgY29uc3QgaXNMaW5lQnJlYWsgPSB0b2tlbiA9PT0gJ1xcbidcbiAgICAvLyBGaXJzdCBjaGVja2luZyBpZiB0aGV5J3JlIGF0dHJpYnV0ZXMgdmFsdWVzXG4gICAgaWYgKGluSnN4VGFnKCkpIHtcbiAgICAgIGlmIChpblN0cmluZ1F1b3RlcygpKSB7XG4gICAgICAgIHJldHVybiBUX1NUUklOR1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbLCBsYXN0VG9rZW5dID0gbGFzdFxuICAgICAgaWYgKGlzSWRlbnRpZmllcih0b2tlbikpIHtcbiAgICAgICAgLy8gY2xhc3NpZnkganN4IG9wZW4gdGFnXG4gICAgICAgIGlmICgobGFzdFRva2VuID09PSAnPCcgfHwgbGFzdFRva2VuID09PSAnPC8nKSkgXG4gICAgICAgICAgcmV0dXJuIFRfRU5USVRZXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRoZW4gZGV0ZXJtaW5lIGlmIHRoZXkncmUganN4IGxpdGVyYWxzXG4gICAgY29uc3QgaXNKc3hMaXRlcmFscyA9IGluSnN4TGl0ZXJhbHMoKVxuICAgIGlmIChpc0pzeExpdGVyYWxzKSByZXR1cm4gVF9KU1hfTElURVJBTFNcblxuICAgIC8vIERldGVybWluZSBzdHJpbmdzIGZpcnN0IGJlZm9yZSBvdGhlciB0eXBlc1xuICAgIGlmIChpblN0cmluZ1F1b3RlcygpKSB7XG4gICAgICByZXR1cm4gVF9TVFJJTkdcbiAgICB9IGVsc2UgaWYgKGtleXdvcmRzLmhhcyh0b2tlbikpIHtcbiAgICAgIHJldHVybiBsYXN0WzFdID09PSAnLicgPyBUX0lERU5USUZJRVIgOiBUX0tFWVdPUkRcbiAgICB9IGVsc2UgaWYgKGlzTGluZUJyZWFrKSB7XG4gICAgICByZXR1cm4gVF9CUkVBS1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZXModG9rZW4pKSB7XG4gICAgICByZXR1cm4gVF9TUEFDRVxuICAgIH0gZWxzZSBpZiAodG9rZW4uc3BsaXQoJycpLmV2ZXJ5KGlzU2lnbikpIHtcbiAgICAgIHJldHVybiBUX1NJR05cbiAgICB9IGVsc2UgaWYgKGlzQ2xzKHRva2VuKSkge1xuICAgICAgcmV0dXJuIGluSnN4VGFnKCkgPyBUX0lERU5USUZJRVIgOiBUX0NMU19OVU1CRVJcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzSWRlbnRpZmllcih0b2tlbikpIHtcbiAgICAgICAgY29uc3QgaXNMYXN0UHJvcERvdCA9IGxhc3RbMV0gPT09ICcuJyAmJiBpc0lkZW50aWZpZXIoYmVmb3JlTGFzdFsxXSlcblxuICAgICAgICBpZiAoIWluU3RyaW5nQ29udGVudCgpICYmICFpc0xhc3RQcm9wRG90KSByZXR1cm4gVF9JREVOVElGSUVSXG4gICAgICAgIGlmIChpc0xhc3RQcm9wRG90KSByZXR1cm4gVF9QUk9QRVJUWVxuICAgICAgfVxuICAgICAgcmV0dXJuIFRfU1RSSU5HXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHlwZV8gXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbl8gXG4gICAqL1xuICBjb25zdCBhcHBlbmQgPSAodHlwZV8sIHRva2VuXykgPT4ge1xuICAgIGlmICh0eXBlXyB8fCB0b2tlbl8pIHtcbiAgICAgIGNvbnN0IG5UeXBlID0gdHlwZXNbdHlwZV9dXG4gICAgfVxuICAgIGlmICh0b2tlbl8pIHtcbiAgICAgIGN1cnJlbnQgPSB0b2tlbl9cbiAgICB9XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIHR5cGUgPSB0eXBlXyB8fCBjbGFzc2lmeShjdXJyZW50KVxuICAgICAgLyoqIEB0eXBlIFtudW1iZXIsIHN0cmluZ10gICovXG4gICAgICBjb25zdCBwYWlyID0gW3R5cGUsIGN1cnJlbnRdXG4gICAgICBpZiAodHlwZSAhPT0gVF9TUEFDRSAmJiB0eXBlICE9PSBUX0JSRUFLKSB7XG4gICAgICAgIGJlZm9yZUxhc3QgPSBsYXN0XG4gICAgICAgIGxhc3QgPSBwYWlyXG4gICAgICB9XG4gICAgICB0b2tlbnMucHVzaChwYWlyKVxuICAgIH1cbiAgICBjdXJyZW50ID0gJydcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyID0gY29kZVtpXVxuICAgIGNvbnN0IHByZXYgPSBjb2RlW2kgLSAxXVxuICAgIGNvbnN0IG5leHQgPSBjb2RlW2kgKyAxXVxuICAgIGNvbnN0IHBfYyA9IHByZXYgKyBjdXJyIC8vIHByZXZpb3VzIGFuZCBjdXJyZW50XG4gICAgY29uc3QgY19uID0gY3VyciArIG5leHQgLy8gY3VycmVudCBhbmQgbmV4dFxuXG4gICAgLy8gRGV0ZXJtaW5lIHN0cmluZyBxdW90YXRpb24gb3V0c2lkZSBvZiBqc3ggbGl0ZXJhbHMuXG4gICAgLy8gSW5zaWRlIGpzeCBsaXRlcmFscywgc3RyaW5nIHF1b3RhdGlvbiBpcyBzdGlsbCBwYXJ0IG9mIGl0LlxuICAgIGlmIChpc1NpbmdsZVF1b3RlcyhjdXJyKSAmJiAhaW5Kc3hMaXRlcmFscygpKSB7XG4gICAgICBhcHBlbmQoKVxuICAgICAgaWYgKHByZXYgIT09IGBcXFxcYCkge1xuICAgICAgICBpZiAoX19zdHJRdW90ZSAmJiBjdXJyID09PSBfX3N0clF1b3RlKSB7XG4gICAgICAgICAgX19zdHJRdW90ZSA9IG51bGxcbiAgICAgICAgfSBlbHNlIGlmICghX19zdHJRdW90ZSkge1xuICAgICAgICAgIF9fc3RyUXVvdGUgPSBjdXJyXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXBwZW5kKFRfU1RSSU5HLCBjdXJyKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoIWluU3RyVGVtcGxhdGVMaXRlcmFscygpKSB7XG4gICAgICBpZiAocHJldiAhPT0gJ1xcXFxuJyAmJiBpc1N0clRlbXBsYXRlQ2hyKGN1cnIpKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGFwcGVuZChUX1NUUklORywgY3VycilcbiAgICAgICAgX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2srK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpblN0clRlbXBsYXRlTGl0ZXJhbHMoKSkge1xuICAgICAgaWYgKHByZXYgIT09ICdcXFxcbicgJiYgaXNTdHJUZW1wbGF0ZUNocihjdXJyKSkge1xuICAgICAgICBpZiAoX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPiAwKSB7XG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBfX3N0clRlbXBsYXRlUXVvdGVTdGFjay0tXG4gICAgICAgICAgYXBwZW5kKFRfU1RSSU5HLCBjdXJyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNfbiA9PT0gJyR7Jykge1xuICAgICAgICBfX3N0clRlbXBsYXRlRXhwclN0YWNrKytcbiAgICAgICAgYXBwZW5kKFRfU1RSSU5HKVxuICAgICAgICBhcHBlbmQoVF9TSUdOLCBjX24pXG4gICAgICAgIGkrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpblN0clRlbXBsYXRlRXhwcigpICYmIGN1cnIgPT09ICd9Jykge1xuICAgICAgYXBwZW5kKClcbiAgICAgIF9fc3RyVGVtcGxhdGVFeHByU3RhY2stLVxuICAgICAgYXBwZW5kKFRfU0lHTiwgY3VycilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKF9fanN4Q2hpbGQoKSkge1xuICAgICAgaWYgKGN1cnIgPT09ICd7Jykge1xuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBhcHBlbmQoVF9TSUdOLCBjdXJyKVxuICAgICAgICBfX2pzeEV4cHIgPSB0cnVlXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9fanN4RW50ZXIpIHtcbiAgICAgIC8vIDw6IG9wZW4gdGFnIHNpZ25cbiAgICAgIC8vIG5ldyAnPCcgbm90IGluc2lkZSBqc3hcbiAgICAgIGlmICghX19qc3hUYWcgJiYgY3VyciA9PT0gJzwnKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGlmIChuZXh0ID09PSAnLycpIHtcbiAgICAgICAgICAvLyBjbG9zZSB0YWdcbiAgICAgICAgICBfX2pzeFRhZyA9IDJcbiAgICAgICAgICBjdXJyZW50ID0gY19uXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3BlbiB0YWdcbiAgICAgICAgICBfX2pzeFRhZyA9IDFcbiAgICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICB9XG4gICAgICAgIGFwcGVuZChUX1NJR04pXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoX19qc3hUYWcpIHtcbiAgICAgICAgLy8gPjogb3BlbiB0YWcgY2xvc2Ugc2lnbiBvciBjbG9zaW5nIHRhZyBjbG9zaW5nIHNpZ25cbiAgICAgICAgLy8gYW5kIGl0J3Mgbm90IGA9PmAgb3IgYC8+YFxuICAgICAgICAvLyBgY3VycmAgY291bGQgYmUgYD5gIG9yIGAvYFxuICAgICAgICBpZiAoKGN1cnIgPT09ICc+JyAmJiAhJy89Jy5pbmNsdWRlcyhwcmV2KSkpIHtcbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIGlmIChfX2pzeFRhZyA9PT0gMSkge1xuICAgICAgICAgICAgX19qc3hUYWcgPSAwXG4gICAgICAgICAgICBfX2pzeFN0YWNrKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX19qc3hUYWcgPSAwXG4gICAgICAgICAgICBfX2pzeEVudGVyID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgYXBwZW5kKFRfU0lHTiwgY3VycilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gPjogdGFnIHNlbGYgY2xvc2Ugc2lnbiBvciBjbG9zZSB0YWcgc2lnblxuICAgICAgICBpZiAoY19uID09PSAnLz4nIHx8IGNfbiA9PT0gJzwvJykge1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdG9rZW4gaXMgbm90IHBhcnQgb2YgY2xvc2UgdGFnIHNpZ24sIHB1c2ggaXQgZmlyc3RcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gJzwnICYmIGN1cnJlbnQgIT09ICcvJykge1xuICAgICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY19uID09PSAnLz4nKSB7XG4gICAgICAgICAgICBfX2pzeFRhZyA9IDBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXMgJzwvJ1xuICAgICAgICAgICAgX19qc3hTdGFjay0tXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfX2pzeFN0YWNrKVxuICAgICAgICAgICAgX19qc3hFbnRlciA9IGZhbHNlXG5cbiAgICAgICAgICBjdXJyZW50ID0gY19uXG4gICAgICAgICAgaSsrXG4gICAgICAgICAgYXBwZW5kKFRfU0lHTilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gPDogb3BlbiB0YWcgc2lnblxuICAgICAgICBpZiAoY3VyciA9PT0gJzwnKSB7XG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICAgIGFwcGVuZChUX1NJR04pXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGpzeCBwcm9wZXJ0eVxuICAgICAgICAvLyBgLWAgaW4gZGF0YS1wcm9wXG4gICAgICAgIGlmIChuZXh0ID09PSAnLScgICYmICFpblN0cmluZ0NvbnRlbnQoKSAmJiAhaW5Kc3hMaXRlcmFscygpKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGFwcGVuZChUX1BST1BFUlRZLCBjdXJyZW50ICsgY3VyciArIG5leHQpXG4gICAgICAgICAgICBpICs9IDFcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGA9YCBpbiBwcm9wZXJ0eT08dmFsdWU+XG4gICAgICAgIGlmIChuZXh0ID09PSAnPScgJiYgIWluU3RyaW5nQ29udGVudCgpKSB7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCBpcyBub3QgYSBzcGFjZSwgZW5zdXJlIGBwcm9wYCBpcyBhIHByb3BlcnR5XG4gICAgICAgICAgaWYgKGlzU3BhY2VzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBhcHBlbmQoVF9TUEFDRSwgY3VycmVudClcbiAgICAgICAgICAgIGN1cnJlbnQgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwcm9wID0gY3VycmVudCA/IChjdXJyZW50ICsgY3VycikgOiBjdXJyXG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllcihwcm9wKSkge1xuICAgICAgICAgICAgY3VycmVudCA9IHByb3BcbiAgICAgICAgICAgIGFwcGVuZChUX1BST1BFUlRZKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgaXQncyBub3QgaW4gYSBqc3ggdGFnIGRlY2xhcmF0aW9uIG9yIGEgc3RyaW5nLCBjbG9zZSBjaGlsZCBpZiBuZXh0IGlzIGpzeCBjbG9zZSB0YWdcbiAgICBpZiAoIV9fanN4VGFnICYmIChjdXJyID09PSAnPCcgJiYgaXNJZGVudGlmaWVyQ2hhcihuZXh0KSB8fCBjX24gPT09ICc8LycpKSB7XG4gICAgICBfX2pzeFRhZyA9IG5leHQgPT09ICcvJyA/IDIgOiAxXG5cbiAgICAgIC8vIGN1cnJlbnQgYW5kIG5leHQgY2hhciBjYW4gZm9ybSBhIGpzeCBvcGVuIG9yIGNsb3NlIHRhZ1xuICAgICAgaWYgKGN1cnIgPT09ICc8JyAmJiAobmV4dCA9PT0gJy8nIHx8IGlzQWxwaGEobmV4dCkpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5TdHJpbmdDb250ZW50KCkgJiYgXG4gICAgICAgICAgIWluSnN4TGl0ZXJhbHMoKSAmJlxuICAgICAgICAgICFpblJlZ2V4UXVvdGVzKClcbiAgICAgICAgKSB7XG4gICAgICAgICAgX19qc3hFbnRlciA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzUXVvdGF0aW9uQ2hhciA9IGlzU3RyaW5nUXVvdGF0aW9uKGN1cnIpXG4gICAgY29uc3QgaXNTdHJpbmdUZW1wbGF0ZUxpdGVyYWxzID0gaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKClcbiAgICBjb25zdCBpc1JlZ2V4Q2hhciA9ICFfX2pzeEVudGVyICYmIGlzUmVnZXhTdGFydChjX24pXG4gICAgY29uc3QgaXNKc3hMaXRlcmFscyA9IGluSnN4TGl0ZXJhbHMoKVxuXG4gICAgLy8gc3RyaW5nIHF1b3RhdGlvblxuICAgIGlmIChpc1F1b3RhdGlvbkNoYXIgfHwgaXNTdHJpbmdUZW1wbGF0ZUxpdGVyYWxzIHx8IGlzU2luZ2xlUXVvdGVzKF9fc3RyUXVvdGUpKSB7XG4gICAgICBjdXJyZW50ICs9IGN1cnJcbiAgICB9IGVsc2UgaWYgKGlzUmVnZXhDaGFyKSB7XG4gICAgICBhcHBlbmQoKVxuICAgICAgY29uc3QgW2xhc3RUeXBlLCBsYXN0VG9rZW5dID0gbGFzdFxuICAgICAgLy8gU3BlY2lhbCBjYXNlcyB0aGF0IGFyZSBub3QgY29uc2lkZXJlZCBhcyByZWdleDpcbiAgICAgIC8vICogKGV4cHIxKSAvIGV4cHIyOiBgKWAgYmVmb3JlIGAvYCBvcGVyYXRvciBpcyBzdGlsbCBpbiBleHByZXNzaW9uXG4gICAgICAvLyAqIDxub24gY29tbWVudCBzdGFydD4vIGV4cHI6IG5vbiBjb21tZW50IHN0YXJ0IGJlZm9yZSBgL2AgaXMgbm90IHJlZ2V4XG4gICAgICBpZiAoXG4gICAgICAgIGlzUmVnZXhDaGFyICYmXG4gICAgICAgIGxhc3RUeXBlICE9PSAtMSAmJlxuICAgICAgICAhKFxuICAgICAgICAgIChsYXN0VHlwZSA9PT0gVF9TSUdOICYmICcpJyAhPT0gbGFzdFRva2VuKSB8fFxuICAgICAgICAgIGxhc3RUeXBlID09PSBUX0NPTU1FTlRcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIF9fcmVnZXhRdW90ZVN0YXJ0ID0gdHJ1ZVxuICAgICAgY29uc3Qgc3RhcnQgPSBpKytcblxuICAgICAgLy8gZW5kIG9mIGxpbmUgb2YgZW5kIG9mIGZpbGVcbiAgICAgIGNvbnN0IGlzRW9mID0gKCkgPT4gaSA+PSBjb2RlLmxlbmd0aFxuICAgICAgY29uc3QgaXNFb2wgPSAoKSA9PiBpc0VvZigpIHx8IGNvZGVbaV0gPT09ICdcXG4nXG5cbiAgICAgIGxldCBmb3VuZENsb3NlID0gZmFsc2VcbiAgICAgIFxuICAgICAgLy8gdHJhdmVyc2UgdG8gZmluZCBjbG9zaW5nIHJlZ2V4IHNsYXNoXG4gICAgICBmb3IgKDsgIWlzRW9sKCk7IGkrKykge1xuICAgICAgICBpZiAoY29kZVtpXSA9PT0gJy8nICYmIGNvZGVbaSAtIDFdICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICBmb3VuZENsb3NlID0gdHJ1ZVxuICAgICAgICAgIC8vIGVuZCBvZiByZWdleCwgYXBwZW5kIHJlZ2V4IGZsYWdzXG4gICAgICAgICAgd2hpbGUgKHN0YXJ0ICE9PSBpICYmIC9eW2Etel0kLy50ZXN0KGNvZGVbaSArIDFdKSAmJiAhaXNFb2woKSkge1xuICAgICAgICAgICAgaSsrXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fcmVnZXhRdW90ZVN0YXJ0ID0gZmFsc2VcblxuICAgICAgaWYgKHN0YXJ0ICE9PSBpICYmIGZvdW5kQ2xvc2UpIHtcbiAgICAgICAgLy8gSWYgY3VycmVudCBsaW5lIGlzIGZ1bGx5IGNsb3NlZCB3aXRoIHN0cmluZyBxdW90ZXMgb3IgcmVnZXggc2xhc2hlcyxcbiAgICAgICAgLy8gYWRkIHRoZW0gdG8gdG9rZW5zXG4gICAgICAgIGN1cnJlbnQgPSBjb2RlLnNsaWNlKHN0YXJ0LCBpICsgMSlcbiAgICAgICAgYXBwZW5kKFRfU1RSSU5HKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBtYXRjaCBhbnkgb2YgdGhlIGFib3ZlLCBqdXN0IGxlYXZlIGl0IGFzIG9wZXJhdG9yIGFuZCBtb3ZlIG9uXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGkgPSBzdGFydFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDb21tZW50U3RhcnQoY19uKSkge1xuICAgICAgYXBwZW5kKClcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaVxuICAgICAgaWYgKG5leHQgPT09ICcvJykge1xuICAgICAgICBmb3IgKDsgaSA8IGNvZGUubGVuZ3RoICYmIGNvZGVbaV0gIT09ICdcXG4nOyBpKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCBjb2RlLmxlbmd0aCAmJiBjb2RlW2kgLSAxXSArIGNvZGVbaV0gIT09ICcqLyc7IGkrKyk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY29kZS5zbGljZShzdGFydCwgaSArIDEpXG4gICAgICBhcHBlbmQoVF9DT01NRU5UKVxuICAgIH0gZWxzZSBpZiAoY3VyciA9PT0gJyAnIHx8IGN1cnIgPT09ICdcXG4nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnIgPT09ICcgJyAmJlxuICAgICAgICAoXG4gICAgICAgICAgKGlzU3BhY2VzKGN1cnJlbnQpIHx8ICFjdXJyZW50KSB8fFxuICAgICAgICAgIGlzSnN4TGl0ZXJhbHNcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY3VyclxuICAgICAgICBpZiAobmV4dCA9PT0gJzwnKSB7XG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgYXBwZW5kKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9fanN4RXhwciAmJiBjdXJyID09PSAnfScpIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgX19qc3hFeHByID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIGl0J3MganN4IGxpdGVyYWxzIGFuZCBpcyBub3QgYSBqc3ggYnJhY2tldFxuICAgICAgICAoaXNKc3hMaXRlcmFscyAmJiAhanN4QnJhY2tldHMuaGFzKGN1cnIpKSB8fFxuICAgICAgICAvLyBzYW1lIHR5cGUgY2hhciBhcyBwcmV2aW91cyBvbmUgaW4gY3VycmVudCB0b2tlblxuICAgICAgICAoKGlzV29yZChjdXJyKSA9PT0gaXNXb3JkKGN1cnJlbnRbY3VycmVudC5sZW5ndGggLSAxXSkgfHwgX19qc3hDaGlsZCgpKSAmJiAhc2lnbnMuaGFzKGN1cnIpKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY3VyclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBfYyA9PT0gJzwvJykge1xuICAgICAgICAgIGN1cnJlbnQgPSBwX2NcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQoKVxuXG4gICAgICAgIGlmIChwX2MgIT09ICc8LycpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VyclxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjX24gPT09ICc8LycgfHwgY19uID09PSAnLz4nKSkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjX25cbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIGkrK1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzeEJyYWNrZXRzLmhhcyhjdXJyKSkgYXBwZW5kKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhcHBlbmQoKVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFtudW1iZXIsIHN0cmluZ10+fSB0b2tlbnNcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKHRva2Vucykge1xuICBjb25zdCBsaW5lcyA9IFtdXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gY2hpbGRyZW5cbiAgICogQHJldHVybiB7e3R5cGU6IHN0cmluZywgdGFnTmFtZTogc3RyaW5nLCBjaGlsZHJlbjogYW55W10sIHByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz59fVxuICAgKi9cbiAgY29uc3QgY3JlYXRlTGluZSA9IChjaGlsZHJlbikgPT4gXG4gICAgICAoe1xuICAgICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICAgIHRhZ05hbWU6ICdzcGFuJyxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdzaF9fbGluZScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PFtudW1iZXIsIHN0cmluZ10+fSB0b2tlbnNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiBmbHVzaExpbmUodG9rZW5zKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqL1xuICAgIGNvbnN0IGxpbmVUb2tlbnMgPSAoXG4gICAgICB0b2tlbnNcbiAgICAgICAgLm1hcCgoW3R5cGUsIHZhbHVlXSkgPT4gKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdlbGVtZW50JyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdzcGFuJyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwgLy8gdG8gZW5jb2RlXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBgc2hfX3Rva2VuLS0ke3R5cGVzW3R5cGVdfWAsXG4gICAgICAgICAgICAgIHN0eWxlOiBgY29sb3I6IHZhcigtLXNoLSR7dHlwZXNbdHlwZV19KWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cbiAgICAgICAgKSlcbiAgICApXG4gICAgbGluZXMucHVzaChjcmVhdGVMaW5lKGxpbmVUb2tlbnMpKVxuICB9XG4gIC8qKiBAdHlwZSB7QXJyYXk8W251bWJlciwgc3RyaW5nXT59ICovXG4gIGNvbnN0IGxpbmVUb2tlbnMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldXG4gICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IHRva2VuXG4gICAgaWYgKHR5cGUgIT09IFRfQlJFQUspIHtcbiAgICAgIC8vIERpdmlkZSBtdWx0aS1saW5lIHRva2VuIGludG8gbXVsdGktbGluZSBjb2RlXG4gICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdmFsdWUuc3BsaXQoJ1xcbicpXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsaW5lVG9rZW5zLnB1c2goW3R5cGUsIGxpbmVzW2pdXSlcbiAgICAgICAgICBpZiAoaiA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZsdXNoTGluZShsaW5lVG9rZW5zKVxuICAgICAgICAgICAgbGluZVRva2Vucy5sZW5ndGggPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lVG9rZW5zLnB1c2godG9rZW4pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVUb2tlbnMucHVzaChbdHlwZSwgJyddKVxuICAgICAgZmx1c2hMaW5lKGxpbmVUb2tlbnMpXG4gICAgICBsaW5lVG9rZW5zLmxlbmd0aCA9IDBcbiAgICB9XG4gIH1cblxuICBpZiAobGluZVRva2Vucy5sZW5ndGgpXG4gICAgZmx1c2hMaW5lKGxpbmVUb2tlbnMpXG5cbiAgcmV0dXJuIGxpbmVzXG59XG5cbmZ1bmN0aW9uIHRvSHRtbChsaW5lcykge1xuICByZXR1cm4gbGluZXNcbiAgICAubWFwKGxpbmUgPT4ge1xuICAgICAgY29uc3QgeyB0YWdOYW1lOiBsaW5lVGFnIH0gPSBsaW5lXG4gICAgICBjb25zdCB0b2tlbnMgPSBsaW5lLmNoaWxkcmVuXG4gICAgICAgIC5tYXAoY2hpbGQgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdGFnTmFtZSwgY2hpbGRyZW4sIHByb3BlcnRpZXMgfSA9IGNoaWxkXG4gICAgICAgICAgcmV0dXJuIGA8JHt0YWdOYW1lfSBjbGFzcz1cIiR7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNsYXNzTmFtZVxuICAgICAgICAgIH1cIiBzdHlsZT1cIiR7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnN0eWxlXG4gICAgICAgICAgfVwiPiR7ZW5jb2RlKGNoaWxkcmVuWzBdLnZhbHVlKX08LyR7dGFnTmFtZX0+YFxuICAgICAgICB9KVxuICAgICAgICAuam9pbignJylcbiAgICAgIHJldHVybiBgPCR7bGluZVRhZ30gY2xhc3M9XCIke2xpbmUucHJvcGVydGllcy5jbGFzc05hbWV9XCI+JHt0b2tlbnN9PC8ke2xpbmVUYWd9PmBcbiAgICB9KVxuICAgIC5qb2luKCdcXG4nKVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaGlnaGxpZ2h0KGNvZGUpIHtcbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoY29kZSlcbiAgY29uc3QgbGluZXMgPSBnZW5lcmF0ZSh0b2tlbnMpXG4gIGNvbnN0IG91dHB1dCA9IHRvSHRtbChsaW5lcylcbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vLyBuYW1lc3BhY2VcbmNvbnN0IFN1Z2FySGlnaCA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIHtcbiAgVG9rZW5UeXBlczogdHlwZXMsXG4gIFRva2VuTWFwOiBuZXcgTWFwKHR5cGVzLm1hcCgodHlwZSwgaSkgPT4gW3R5cGUsIGldKSksXG59XG5cbmV4cG9ydCB7XG4gIGhpZ2hsaWdodCxcbiAgdG9rZW5pemUsXG4gIGdlbmVyYXRlLFxuICBTdWdhckhpZ2gsXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sugar-high/lib/index.js\n");

/***/ })

};
;